/*
 * Slack Web API
 *
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * The version of the OpenAPI document: 1.5.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `remote_add`
#[derive(Clone, Debug)]
pub struct RemoteAddParams {
    /// Title of the file being shared.
    pub title: Option<String>,
    /// type of file
    pub filetype: Option<String>,
    /// Authentication token. Requires scope: `remote_files:write`
    pub token: Option<String>,
    /// A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file.
    pub indexable_file_contents: Option<String>,
    /// Preview of the document via `multipart/form-data`.
    pub preview_image: Option<String>,
    /// Creator defined GUID for the file.
    pub external_id: Option<String>,
    /// URL of the remote file.
    pub external_url: Option<String>
}

/// struct for passing parameters to the method `remote_info`
#[derive(Clone, Debug)]
pub struct RemoteInfoParams {
    /// Authentication token. Requires scope: `remote_files:read`
    pub token: Option<String>,
    /// Creator defined GUID for the file.
    pub external_id: Option<String>,
    /// Specify a file by providing its ID.
    pub file: Option<String>
}

/// struct for passing parameters to the method `remote_list`
#[derive(Clone, Debug)]
pub struct RemoteListParams {
    /// Filter files created before this timestamp (inclusive).
    pub ts_to: Option<f32>,
    /// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.
    pub cursor: Option<String>,
    /// Filter files created after this timestamp (inclusive).
    pub ts_from: Option<f32>,
    /// Authentication token. Requires scope: `remote_files:read`
    pub token: Option<String>,
    /// The maximum number of items to return.
    pub limit: Option<i32>,
    /// Filter files appearing in a specific channel, indicated by its ID.
    pub channel: Option<String>
}

/// struct for passing parameters to the method `remote_remove`
#[derive(Clone, Debug)]
pub struct RemoteRemoveParams {
    /// Authentication token. Requires scope: `remote_files:write`
    pub token: Option<String>,
    /// Creator defined GUID for the file.
    pub external_id: Option<String>,
    /// Specify a file by providing its ID.
    pub file: Option<String>
}

/// struct for passing parameters to the method `remote_share`
#[derive(Clone, Debug)]
pub struct RemoteShareParams {
    /// Comma-separated list of channel IDs where the file will be shared.
    pub channels: Option<String>,
    /// Authentication token. Requires scope: `remote_files:share`
    pub token: Option<String>,
    /// Creator defined GUID for the file.
    pub external_id: Option<String>,
    /// Specify a file by providing its ID.
    pub file: Option<String>
}

/// struct for passing parameters to the method `remote_update`
#[derive(Clone, Debug)]
pub struct RemoteUpdateParams {
    /// Title of the file being shared.
    pub title: Option<String>,
    /// type of file
    pub filetype: Option<String>,
    /// Authentication token. Requires scope: `remote_files:write`
    pub token: Option<String>,
    /// Specify a file by providing its ID.
    pub file: Option<String>,
    /// File containing contents that can be used to improve searchability for the remote file.
    pub indexable_file_contents: Option<String>,
    /// Preview of the document via `multipart/form-data`.
    pub preview_image: Option<String>,
    /// Creator defined GUID for the file.
    pub external_id: Option<String>,
    /// URL of the remote file.
    pub external_url: Option<String>
}


/// struct for typed errors of method `remote_add`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoteAddError {
    DefaultResponse(::std::collections::HashMap<String, serde_json::Value>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remote_info`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoteInfoError {
    DefaultResponse(::std::collections::HashMap<String, serde_json::Value>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remote_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoteListError {
    DefaultResponse(::std::collections::HashMap<String, serde_json::Value>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remote_remove`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoteRemoveError {
    DefaultResponse(::std::collections::HashMap<String, serde_json::Value>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remote_share`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoteShareError {
    DefaultResponse(::std::collections::HashMap<String, serde_json::Value>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remote_update`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoteUpdateError {
    DefaultResponse(::std::collections::HashMap<String, serde_json::Value>),
    UnknownValue(serde_json::Value),
}


/// Adds a file from a remote service
pub async fn remote_add(configuration: &configuration::Configuration, params: RemoteAddParams) -> Result<::std::collections::HashMap<String, serde_json::Value>, Error<RemoteAddError>> {
    // unbox the parameters
    let title = params.title;
    let filetype = params.filetype;
    let token = params.token;
    let indexable_file_contents = params.indexable_file_contents;
    let preview_image = params.preview_image;
    let external_id = params.external_id;
    let external_url = params.external_url;


    let client = &configuration.client;

    let uri_str = format!("{}/files.remote.add", configuration.base_path);
    let mut req_builder = client.post(uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut form_params = std::collections::HashMap::new();
    if let Some(param_value) = title {
        form_params.insert("title", param_value.to_string());
    }
    if let Some(param_value) = filetype {
        form_params.insert("filetype", param_value.to_string());
    }
    if let Some(param_value) = token {
        form_params.insert("token", param_value.to_string());
    }
    if let Some(param_value) = indexable_file_contents {
        form_params.insert("indexable_file_contents", param_value.to_string());
    }
    if let Some(param_value) = preview_image {
        form_params.insert("preview_image", param_value.to_string());
    }
    if let Some(param_value) = external_id {
        form_params.insert("external_id", param_value.to_string());
    }
    if let Some(param_value) = external_url {
        form_params.insert("external_url", param_value.to_string());
    }
    req_builder = req_builder.form(&form_params);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    let data: Option<::std::collections::HashMap<String, serde_json::Value>> = serde_json::from_str(&content).ok();

    if data.is_some() {
		Ok(data.unwrap())
    } else {
        let entity: Option<RemoteAddError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status, content, entity };
        Err(Error::ResponseError(error))
    }
}

/// Retrieve information about a remote file added to Slack
pub async fn remote_info(configuration: &configuration::Configuration, params: RemoteInfoParams) -> Result<::std::collections::HashMap<String, serde_json::Value>, Error<RemoteInfoError>> {
    // unbox the parameters
    let token = params.token;
    let external_id = params.external_id;
    let file = params.file;


    let client = &configuration.client;

    let uri_str = format!("{}/files.remote.info", configuration.base_path);
    let mut req_builder = client.get(uri_str.as_str());

    if let Some(ref s) = token {
        req_builder = req_builder.query(&[("token", &s.to_string())]);
    }
    if let Some(ref s) = external_id {
        req_builder = req_builder.query(&[("external_id", &s.to_string())]);
    }
    if let Some(ref s) = file {
        req_builder = req_builder.query(&[("file", &s.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    let data: Option<::std::collections::HashMap<String, serde_json::Value>> = serde_json::from_str(&content).ok();

    if data.is_some() {
		Ok(data.unwrap())
    } else {
        let entity: Option<RemoteInfoError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status, content, entity };
        Err(Error::ResponseError(error))
    }
}

/// Retrieve information about a remote file added to Slack
pub async fn remote_list(configuration: &configuration::Configuration, params: RemoteListParams) -> Result<::std::collections::HashMap<String, serde_json::Value>, Error<RemoteListError>> {
    // unbox the parameters
    let ts_to = params.ts_to;
    let cursor = params.cursor;
    let ts_from = params.ts_from;
    let token = params.token;
    let limit = params.limit;
    let channel = params.channel;


    let client = &configuration.client;

    let uri_str = format!("{}/files.remote.list", configuration.base_path);
    let mut req_builder = client.get(uri_str.as_str());

    if let Some(ref s) = ts_to {
        req_builder = req_builder.query(&[("ts_to", &s.to_string())]);
    }
    if let Some(ref s) = cursor {
        req_builder = req_builder.query(&[("cursor", &s.to_string())]);
    }
    if let Some(ref s) = ts_from {
        req_builder = req_builder.query(&[("ts_from", &s.to_string())]);
    }
    if let Some(ref s) = token {
        req_builder = req_builder.query(&[("token", &s.to_string())]);
    }
    if let Some(ref s) = limit {
        req_builder = req_builder.query(&[("limit", &s.to_string())]);
    }
    if let Some(ref s) = channel {
        req_builder = req_builder.query(&[("channel", &s.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    let data: Option<::std::collections::HashMap<String, serde_json::Value>> = serde_json::from_str(&content).ok();

    if data.is_some() {
		Ok(data.unwrap())
    } else {
        let entity: Option<RemoteListError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status, content, entity };
        Err(Error::ResponseError(error))
    }
}

/// Remove a remote file.
pub async fn remote_remove(configuration: &configuration::Configuration, params: RemoteRemoveParams) -> Result<::std::collections::HashMap<String, serde_json::Value>, Error<RemoteRemoveError>> {
    // unbox the parameters
    let token = params.token;
    let external_id = params.external_id;
    let file = params.file;


    let client = &configuration.client;

    let uri_str = format!("{}/files.remote.remove", configuration.base_path);
    let mut req_builder = client.post(uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut form_params = std::collections::HashMap::new();
    if let Some(param_value) = token {
        form_params.insert("token", param_value.to_string());
    }
    if let Some(param_value) = external_id {
        form_params.insert("external_id", param_value.to_string());
    }
    if let Some(param_value) = file {
        form_params.insert("file", param_value.to_string());
    }
    req_builder = req_builder.form(&form_params);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    let data: Option<::std::collections::HashMap<String, serde_json::Value>> = serde_json::from_str(&content).ok();

    if data.is_some() {
		Ok(data.unwrap())
    } else {
        let entity: Option<RemoteRemoveError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status, content, entity };
        Err(Error::ResponseError(error))
    }
}

/// Share a remote file into a channel.
pub async fn remote_share(configuration: &configuration::Configuration, params: RemoteShareParams) -> Result<::std::collections::HashMap<String, serde_json::Value>, Error<RemoteShareError>> {
    // unbox the parameters
    let channels = params.channels;
    let token = params.token;
    let external_id = params.external_id;
    let file = params.file;


    let client = &configuration.client;

    let uri_str = format!("{}/files.remote.share", configuration.base_path);
    let mut req_builder = client.get(uri_str.as_str());

    if let Some(ref s) = channels {
        req_builder = req_builder.query(&[("channels", &s.to_string())]);
    }
    if let Some(ref s) = token {
        req_builder = req_builder.query(&[("token", &s.to_string())]);
    }
    if let Some(ref s) = external_id {
        req_builder = req_builder.query(&[("external_id", &s.to_string())]);
    }
    if let Some(ref s) = file {
        req_builder = req_builder.query(&[("file", &s.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    let data: Option<::std::collections::HashMap<String, serde_json::Value>> = serde_json::from_str(&content).ok();

    if data.is_some() {
		Ok(data.unwrap())
    } else {
        let entity: Option<RemoteShareError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status, content, entity };
        Err(Error::ResponseError(error))
    }
}

/// Updates an existing remote file.
pub async fn remote_update(configuration: &configuration::Configuration, params: RemoteUpdateParams) -> Result<::std::collections::HashMap<String, serde_json::Value>, Error<RemoteUpdateError>> {
    // unbox the parameters
    let title = params.title;
    let filetype = params.filetype;
    let token = params.token;
    let file = params.file;
    let indexable_file_contents = params.indexable_file_contents;
    let preview_image = params.preview_image;
    let external_id = params.external_id;
    let external_url = params.external_url;


    let client = &configuration.client;

    let uri_str = format!("{}/files.remote.update", configuration.base_path);
    let mut req_builder = client.post(uri_str.as_str());

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut form_params = std::collections::HashMap::new();
    if let Some(param_value) = title {
        form_params.insert("title", param_value.to_string());
    }
    if let Some(param_value) = filetype {
        form_params.insert("filetype", param_value.to_string());
    }
    if let Some(param_value) = token {
        form_params.insert("token", param_value.to_string());
    }
    if let Some(param_value) = file {
        form_params.insert("file", param_value.to_string());
    }
    if let Some(param_value) = indexable_file_contents {
        form_params.insert("indexable_file_contents", param_value.to_string());
    }
    if let Some(param_value) = preview_image {
        form_params.insert("preview_image", param_value.to_string());
    }
    if let Some(param_value) = external_id {
        form_params.insert("external_id", param_value.to_string());
    }
    if let Some(param_value) = external_url {
        form_params.insert("external_url", param_value.to_string());
    }
    req_builder = req_builder.form(&form_params);

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    let data: Option<::std::collections::HashMap<String, serde_json::Value>> = serde_json::from_str(&content).ok();

    if data.is_some() {
		Ok(data.unwrap())
    } else {
        let entity: Option<RemoteUpdateError> = serde_json::from_str(&content).ok();
        let error = ResponseContent { status, content, entity };
        Err(Error::ResponseError(error))
    }
}

