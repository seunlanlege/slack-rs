/*
 * Slack Web API
 *
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * The version of the OpenAPI document: 1.5.0
 * 
 * Generated by: https://openapi-generator.tech
 */

#[allow(unused_imports)]
use std::rc::Rc;

use std::option::Option;

use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `archive`
#[derive(Clone, Debug)]
pub struct ArchiveParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// ID of conversation to archive
    pub channel: Option<String>
}

/// struct for passing parameters to the method `close`
#[derive(Clone, Debug)]
pub struct CloseParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// Conversation to close.
    pub channel: Option<String>
}

/// struct for passing parameters to the method `create`
#[derive(Clone, Debug)]
pub struct CreateParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// Name of the public or private channel to create
    pub name: Option<String>,
    /// **Required** for workspace apps. A list of between 1 and 30 human users that will be added to the newly-created conversation. This argument has no effect when used by classic Slack apps.
    pub user_ids: Option<String>,
    /// Create a private channel instead of a public one
    pub is_private: Option<bool>
}

/// struct for passing parameters to the method `history`
#[derive(Clone, Debug)]
pub struct HistoryParams {
    /// Include messages with latest or oldest timestamp in results only when either timestamp is specified.
    pub inclusive: Option<bool>,
    /// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.
    pub cursor: Option<String>,
    /// Authentication token. Requires scope: `conversations:history`
    pub token: Option<String>,
    /// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached.
    pub limit: Option<i32>,
    /// Start of time range of messages to include in results.
    pub oldest: Option<f32>,
    /// Conversation ID to fetch history for.
    pub channel: Option<String>,
    /// End of time range of messages to include in results.
    pub latest: Option<f32>
}

/// struct for passing parameters to the method `info`
#[derive(Clone, Debug)]
pub struct InfoParams {
    /// Set to `true` to include the member count for the specified conversation. Defaults to `false`
    pub include_num_members: Option<bool>,
    /// Authentication token. Requires scope: `conversations:read`
    pub token: Option<String>,
    /// Conversation ID to learn more about
    pub channel: Option<String>,
    /// Set this to `true` to receive the locale for this conversation. Defaults to `false`
    pub include_locale: Option<bool>
}

/// struct for passing parameters to the method `invite`
#[derive(Clone, Debug)]
pub struct InviteParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// A comma separated list of user IDs. Up to 1000 users may be listed.
    pub users: Option<String>,
    /// The ID of the public or private channel to invite user(s) to.
    pub channel: Option<String>
}

/// struct for passing parameters to the method `join`
#[derive(Clone, Debug)]
pub struct JoinParams {
    /// Authentication token. Requires scope: `channels:write`
    pub token: Option<String>,
    /// ID of conversation to join
    pub channel: Option<String>
}

/// struct for passing parameters to the method `kick`
#[derive(Clone, Debug)]
pub struct KickParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// User ID to be removed.
    pub user: Option<String>,
    /// ID of conversation to remove user from.
    pub channel: Option<String>
}

/// struct for passing parameters to the method `leave`
#[derive(Clone, Debug)]
pub struct LeaveParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// Conversation to leave
    pub channel: Option<String>
}

/// struct for passing parameters to the method `list`
#[derive(Clone, Debug)]
pub struct ListParams {
    /// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.
    pub cursor: Option<String>,
    /// Authentication token. Requires scope: `conversations:read`
    pub token: Option<String>,
    /// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. Must be an integer no larger than 1000.
    pub limit: Option<i32>,
    /// Set to `true` to exclude archived channels from the list
    pub exclude_archived: Option<bool>,
    /// Mix and match channel types by providing a comma-separated list of any combination of `public_channel`, `private_channel`, `mpim`, `im`
    pub types: Option<String>
}

/// struct for passing parameters to the method `members`
#[derive(Clone, Debug)]
pub struct MembersParams {
    /// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.
    pub cursor: Option<String>,
    /// Authentication token. Requires scope: `conversations:read`
    pub token: Option<String>,
    /// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached.
    pub limit: Option<i32>,
    /// ID of the conversation to retrieve members for
    pub channel: Option<String>
}

/// struct for passing parameters to the method `open`
#[derive(Clone, Debug)]
pub struct OpenParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// Boolean, indicates you want the full IM channel definition in the response.
    pub return_im: Option<bool>,
    /// Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a `channel` when not supplying `users`.
    pub users: Option<String>,
    /// Resume a conversation by supplying an `im` or `mpim`'s ID. Or provide the `users` field instead.
    pub channel: Option<String>
}

/// struct for passing parameters to the method `rename`
#[derive(Clone, Debug)]
pub struct RenameParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// New name for conversation.
    pub name: Option<String>,
    /// ID of conversation to rename
    pub channel: Option<String>
}

/// struct for passing parameters to the method `replies`
#[derive(Clone, Debug)]
pub struct RepliesParams {
    /// Include messages with latest or oldest timestamp in results only when either timestamp is specified.
    pub inclusive: Option<bool>,
    /// Unique identifier of a thread's parent message.
    pub ts: Option<f32>,
    /// Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](/docs/pagination) for more detail.
    pub cursor: Option<String>,
    /// Authentication token. Requires scope: `conversations:history`
    pub token: Option<String>,
    /// The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached.
    pub limit: Option<i32>,
    /// Start of time range of messages to include in results.
    pub oldest: Option<f32>,
    /// Conversation ID to fetch thread from.
    pub channel: Option<String>,
    /// End of time range of messages to include in results.
    pub latest: Option<f32>
}

/// struct for passing parameters to the method `set_purpose`
#[derive(Clone, Debug)]
pub struct SetPurposeParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// A new, specialer purpose
    pub purpose: Option<String>,
    /// Conversation to set the purpose of
    pub channel: Option<String>
}

/// struct for passing parameters to the method `set_topic`
#[derive(Clone, Debug)]
pub struct SetTopicParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// The new topic string. Does not support formatting or linkification.
    pub topic: Option<String>,
    /// Conversation to set the topic of
    pub channel: Option<String>
}

/// struct for passing parameters to the method `unarchive`
#[derive(Clone, Debug)]
pub struct UnarchiveParams {
    /// Authentication token. Requires scope: `conversations:write`
    pub token: Option<String>,
    /// ID of conversation to unarchive
    pub channel: Option<String>
}


/// struct for typed errors of method `archive`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArchiveError {
    DefaultResponse(crate::models::ConversationsArchiveErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `close`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CloseError {
    DefaultResponse(crate::models::ConversationsCloseErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateError {
    DefaultResponse(crate::models::ConversationsCreateErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `history`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HistoryError {
    DefaultResponse(crate::models::ConversationsHistoryErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `info`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InfoError {
    DefaultResponse(crate::models::ConversationsInfoErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InviteError {
    DefaultResponse(crate::models::ConversationsInviteErrorSchema1),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `join`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum JoinError {
    DefaultResponse(crate::models::ConversationsJoinErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `kick`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KickError {
    DefaultResponse(crate::models::ConversationsKickErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `leave`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaveError {
    DefaultResponse(crate::models::ConversationsLeaveErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListError {
    DefaultResponse(crate::models::ConversationsListErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `members`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MembersError {
    DefaultResponse(crate::models::ConversationsMembersErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `open`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OpenError {
    DefaultResponse(crate::models::ConversationsOpenErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `rename`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RenameError {
    DefaultResponse(crate::models::ConversationsRenameErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `replies`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepliesError {
    DefaultResponse(crate::models::ConversationsRepliesErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_purpose`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetPurposeError {
    DefaultResponse(crate::models::ConversationsSetPurposeErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_topic`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetTopicError {
    DefaultResponse(crate::models::ConversationsSetTopicErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `unarchive`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnarchiveError {
    DefaultResponse(crate::models::ConversationsUnarchiveErrorSchema),
    UnknownValue(serde_json::Value),
}


    pub async fn archive(configuration: &configuration::Configuration, params: ArchiveParams) -> Result<crate::models::ConversationsArchiveSuccessSchema, Error<ArchiveError>> {
        // unbox the parameters
        let token = params.token;
        let channel = params.channel;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.archive", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(param_value) = token {
            req_builder = req_builder.header("token", param_value.to_string());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        if let Some(param_value) = channel {
            form_params.insert("channel", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ArchiveError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn close(configuration: &configuration::Configuration, params: CloseParams) -> Result<crate::models::ConversationsCloseSuccessSchema, Error<CloseError>> {
        // unbox the parameters
        let token = params.token;
        let channel = params.channel;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.close", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(param_value) = token {
            req_builder = req_builder.header("token", param_value.to_string());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        if let Some(param_value) = channel {
            form_params.insert("channel", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<CloseError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn create(configuration: &configuration::Configuration, params: CreateParams) -> Result<crate::models::ConversationsCreateSuccessSchema, Error<CreateError>> {
        // unbox the parameters
        let token = params.token;
        let name = params.name;
        let user_ids = params.user_ids;
        let is_private = params.is_private;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.create", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(param_value) = token {
            req_builder = req_builder.header("token", param_value.to_string());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        if let Some(param_value) = name {
            form_params.insert("name", param_value.to_string());
        }
        if let Some(param_value) = user_ids {
            form_params.insert("user_ids", param_value.to_string());
        }
        if let Some(param_value) = is_private {
            form_params.insert("is_private", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<CreateError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn history(configuration: &configuration::Configuration, params: HistoryParams) -> Result<crate::models::ConversationsHistorySuccessSchema, Error<HistoryError>> {
        // unbox the parameters
        let inclusive = params.inclusive;
        let cursor = params.cursor;
        let token = params.token;
        let limit = params.limit;
        let oldest = params.oldest;
        let channel = params.channel;
        let latest = params.latest;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.history", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = inclusive {
            req_builder = req_builder.query(&[("inclusive", &s.to_string())]);
        }
        if let Some(ref s) = cursor {
            req_builder = req_builder.query(&[("cursor", &s.to_string())]);
        }
        if let Some(ref s) = token {
            req_builder = req_builder.query(&[("token", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = oldest {
            req_builder = req_builder.query(&[("oldest", &s.to_string())]);
        }
        if let Some(ref s) = channel {
            req_builder = req_builder.query(&[("channel", &s.to_string())]);
        }
        if let Some(ref s) = latest {
            req_builder = req_builder.query(&[("latest", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<HistoryError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn info(configuration: &configuration::Configuration, params: InfoParams) -> Result<crate::models::ConversationsInfoSuccessSchema, Error<InfoError>> {
        // unbox the parameters
        let include_num_members = params.include_num_members;
        let token = params.token;
        let channel = params.channel;
        let include_locale = params.include_locale;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.info", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = include_num_members {
            req_builder = req_builder.query(&[("include_num_members", &s.to_string())]);
        }
        if let Some(ref s) = token {
            req_builder = req_builder.query(&[("token", &s.to_string())]);
        }
        if let Some(ref s) = channel {
            req_builder = req_builder.query(&[("channel", &s.to_string())]);
        }
        if let Some(ref s) = include_locale {
            req_builder = req_builder.query(&[("include_locale", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<InfoError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn invite(configuration: &configuration::Configuration, params: InviteParams) -> Result<crate::models::ConversationsInviteErrorSchema, Error<InviteError>> {
        // unbox the parameters
        let token = params.token;
        let users = params.users;
        let channel = params.channel;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.invite", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(param_value) = token {
            req_builder = req_builder.header("token", param_value.to_string());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        if let Some(param_value) = users {
            form_params.insert("users", param_value.to_string());
        }
        if let Some(param_value) = channel {
            form_params.insert("channel", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<InviteError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn join(configuration: &configuration::Configuration, params: JoinParams) -> Result<crate::models::ConversationsJoinSuccessSchema, Error<JoinError>> {
        // unbox the parameters
        let token = params.token;
        let channel = params.channel;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.join", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(param_value) = token {
            req_builder = req_builder.header("token", param_value.to_string());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        if let Some(param_value) = channel {
            form_params.insert("channel", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<JoinError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn kick(configuration: &configuration::Configuration, params: KickParams) -> Result<crate::models::ConversationsKickSuccessSchema, Error<KickError>> {
        // unbox the parameters
        let token = params.token;
        let user = params.user;
        let channel = params.channel;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.kick", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(param_value) = token {
            req_builder = req_builder.header("token", param_value.to_string());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        if let Some(param_value) = user {
            form_params.insert("user", param_value.to_string());
        }
        if let Some(param_value) = channel {
            form_params.insert("channel", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<KickError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn leave(configuration: &configuration::Configuration, params: LeaveParams) -> Result<crate::models::ConversationsLeaveSuccessSchema, Error<LeaveError>> {
        // unbox the parameters
        let token = params.token;
        let channel = params.channel;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.leave", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(param_value) = token {
            req_builder = req_builder.header("token", param_value.to_string());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        if let Some(param_value) = channel {
            form_params.insert("channel", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<LeaveError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn list(configuration: &configuration::Configuration, params: ListParams) -> Result<crate::models::ConversationsListSuccessSchema, Error<ListError>> {
        // unbox the parameters
        let cursor = params.cursor;
        let token = params.token;
        let limit = params.limit;
        let exclude_archived = params.exclude_archived;
        let types = params.types;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.list", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = cursor {
            req_builder = req_builder.query(&[("cursor", &s.to_string())]);
        }
        if let Some(ref s) = token {
            req_builder = req_builder.query(&[("token", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = exclude_archived {
            req_builder = req_builder.query(&[("exclude_archived", &s.to_string())]);
        }
        if let Some(ref s) = types {
            req_builder = req_builder.query(&[("types", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ListError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn members(configuration: &configuration::Configuration, params: MembersParams) -> Result<crate::models::ConversationsMembersSuccessSchema, Error<MembersError>> {
        // unbox the parameters
        let cursor = params.cursor;
        let token = params.token;
        let limit = params.limit;
        let channel = params.channel;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.members", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = cursor {
            req_builder = req_builder.query(&[("cursor", &s.to_string())]);
        }
        if let Some(ref s) = token {
            req_builder = req_builder.query(&[("token", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = channel {
            req_builder = req_builder.query(&[("channel", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<MembersError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn open(configuration: &configuration::Configuration, params: OpenParams) -> Result<crate::models::ConversationsOpenSuccessSchema, Error<OpenError>> {
        // unbox the parameters
        let token = params.token;
        let return_im = params.return_im;
        let users = params.users;
        let channel = params.channel;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.open", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(param_value) = token {
            req_builder = req_builder.header("token", param_value.to_string());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        if let Some(param_value) = return_im {
            form_params.insert("return_im", param_value.to_string());
        }
        if let Some(param_value) = users {
            form_params.insert("users", param_value.to_string());
        }
        if let Some(param_value) = channel {
            form_params.insert("channel", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<OpenError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn rename(configuration: &configuration::Configuration, params: RenameParams) -> Result<crate::models::ConversationsRenameSuccessSchema, Error<RenameError>> {
        // unbox the parameters
        let token = params.token;
        let name = params.name;
        let channel = params.channel;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.rename", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(param_value) = token {
            req_builder = req_builder.header("token", param_value.to_string());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        if let Some(param_value) = name {
            form_params.insert("name", param_value.to_string());
        }
        if let Some(param_value) = channel {
            form_params.insert("channel", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<RenameError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn replies(configuration: &configuration::Configuration, params: RepliesParams) -> Result<crate::models::ConversationsRepliesSuccessSchema, Error<RepliesError>> {
        // unbox the parameters
        let inclusive = params.inclusive;
        let ts = params.ts;
        let cursor = params.cursor;
        let token = params.token;
        let limit = params.limit;
        let oldest = params.oldest;
        let channel = params.channel;
        let latest = params.latest;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.replies", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = inclusive {
            req_builder = req_builder.query(&[("inclusive", &s.to_string())]);
        }
        if let Some(ref s) = ts {
            req_builder = req_builder.query(&[("ts", &s.to_string())]);
        }
        if let Some(ref s) = cursor {
            req_builder = req_builder.query(&[("cursor", &s.to_string())]);
        }
        if let Some(ref s) = token {
            req_builder = req_builder.query(&[("token", &s.to_string())]);
        }
        if let Some(ref s) = limit {
            req_builder = req_builder.query(&[("limit", &s.to_string())]);
        }
        if let Some(ref s) = oldest {
            req_builder = req_builder.query(&[("oldest", &s.to_string())]);
        }
        if let Some(ref s) = channel {
            req_builder = req_builder.query(&[("channel", &s.to_string())]);
        }
        if let Some(ref s) = latest {
            req_builder = req_builder.query(&[("latest", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<RepliesError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn set_purpose(configuration: &configuration::Configuration, params: SetPurposeParams) -> Result<crate::models::ConversationsSetPurposeSuccessSchema, Error<SetPurposeError>> {
        // unbox the parameters
        let token = params.token;
        let purpose = params.purpose;
        let channel = params.channel;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.setPurpose", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(param_value) = token {
            req_builder = req_builder.header("token", param_value.to_string());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        if let Some(param_value) = purpose {
            form_params.insert("purpose", param_value.to_string());
        }
        if let Some(param_value) = channel {
            form_params.insert("channel", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<SetPurposeError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn set_topic(configuration: &configuration::Configuration, params: SetTopicParams) -> Result<crate::models::ConversationsSetTopicSuccessSchema, Error<SetTopicError>> {
        // unbox the parameters
        let token = params.token;
        let topic = params.topic;
        let channel = params.channel;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.setTopic", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(param_value) = token {
            req_builder = req_builder.header("token", param_value.to_string());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        if let Some(param_value) = topic {
            form_params.insert("topic", param_value.to_string());
        }
        if let Some(param_value) = channel {
            form_params.insert("channel", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<SetTopicError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn unarchive(configuration: &configuration::Configuration, params: UnarchiveParams) -> Result<crate::models::ConversationsUnarchiveSuccessSchema, Error<UnarchiveError>> {
        // unbox the parameters
        let token = params.token;
        let channel = params.channel;

        let client = &configuration.client;

        let uri_str = format!("{}/conversations.unarchive", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(param_value) = token {
            req_builder = req_builder.header("token", param_value.to_string());
        }
        if let Some(ref token) = configuration.oauth_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        let mut form_params = std::collections::HashMap::new();
        if let Some(param_value) = channel {
            form_params.insert("channel", param_value.to_string());
        }
        req_builder = req_builder.form(&form_params);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<UnarchiveError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

