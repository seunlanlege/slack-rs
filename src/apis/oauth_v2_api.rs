/*
 * Slack Web API
 *
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * The version of the OpenAPI document: 1.5.0
 *
 * Generated by: https://openapi-generator.tech
 */

#[allow(unused_imports)]
use std::rc::Rc;

use std::option::Option;

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for passing parameters to the method `v2_access`
#[derive(Clone, Debug, Default)]
pub struct V2AccessParams {
    /// The `code` param returned via the OAuth callback.
    pub code: String,
    /// Issued when you created your application.
    pub client_secret: Option<String>,
    /// Issued when you created your application.
    pub client_id: Option<String>,
    /// This must match the originally submitted URI (if one was sent).
    pub redirect_uri: Option<String>,
}

/// struct for typed errors of method `v2_access`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2AccessError {
    DefaultResponse(::std::collections::HashMap<String, serde_json::Value>),
    UnknownValue(serde_json::Value),
}

#[derive(Default, Debug, Clone, PartialEq, serde_derive::Serialize, serde_derive::Deserialize)]
pub struct AuthPayload {
    pub ok: bool,
    pub access_token: Option<String>,
    pub token_type: Option<String>,
    pub scope: Option<String>,
    pub bot_user_id: Option<String>,
    pub app_id: String,
    pub team: Team,
    pub enterprise: Option<Enterprise>,
    pub authed_user: AuthedUser,
}

#[derive(Default, Debug, Clone, PartialEq, serde_derive::Serialize, serde_derive::Deserialize)]
pub struct Team {
    pub name: String,
    pub id: String,
}

#[derive(Default, Debug, Clone, PartialEq, serde_derive::Serialize, serde_derive::Deserialize)]
pub struct Enterprise {
    pub name: String,
    pub id: String,
}

#[derive(Default, Debug, Clone, PartialEq, serde_derive::Serialize, serde_derive::Deserialize)]
pub struct AuthedUser {
    pub id: String,
    pub scope: String,
    pub access_token: String,
    pub token_type: String,
}


pub async fn v2_access(
    configuration: &configuration::Configuration,
    params: V2AccessParams,
) -> Result<AuthPayload, Error<V2AccessError>> {
    // unbox the parameters
    let code = params.code;
    let client_secret = params.client_secret;
    let client_id = params.client_id;
    let redirect_uri = params.redirect_uri;

    let client = &configuration.client;

    let uri_str = format!("{}/oauth.v2.access", configuration.base_path);
    let mut req_builder = client.get(uri_str.as_str());

    if let Some(ref s) = client_secret {
        req_builder = req_builder.query(&[("client_secret", &s.to_string())]);
    }
    req_builder = req_builder.query(&[("code", &code.to_string())]);
    if let Some(ref s) = client_id {
        req_builder = req_builder.query(&[("client_id", &s.to_string())]);
    }
    if let Some(ref s) = redirect_uri {
        req_builder = req_builder.query(&[("redirect_uri", &s.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = client.execute(req).await?;

    let status = resp.status();
    let content = resp.text().await?;

    if status.is_success() {
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let entity: Option<V2AccessError> = serde_json::from_str(&content).ok();
        let error = ResponseContent {
            status,
            content,
            entity,
        };
        Err(Error::ResponseError(error))
    }
}
